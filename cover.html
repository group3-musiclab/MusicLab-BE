
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>services: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">musiclab-be/features/auth/services/service.go (94.4%)</option>
				
				<option value="file1">musiclab-be/features/chats/services/service.go (100.0%)</option>
				
				<option value="file2">musiclab-be/features/classes/services/service.go (97.7%)</option>
				
				<option value="file3">musiclab-be/features/genres/services/service.go (96.4%)</option>
				
				<option value="file4">musiclab-be/features/instruments/services/service.go (100.0%)</option>
				
				<option value="file5">musiclab-be/features/mentors/services/service.go (87.3%)</option>
				
				<option value="file6">musiclab-be/features/reviews/services/service.go (100.0%)</option>
				
				<option value="file7">musiclab-be/features/schedules/services/service.go (100.0%)</option>
				
				<option value="file8">musiclab-be/features/students/services/service.go (87.5%)</option>
				
				<option value="file9">musiclab-be/features/transactions/services/service.go (84.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package services

import (
        "errors"
        "musiclab-be/features/auth"
        "musiclab-be/features/classes"
        "musiclab-be/features/mentors"
        "musiclab-be/features/schedules"
        "musiclab-be/features/students"
        "musiclab-be/features/transactions"
        "musiclab-be/utils/consts"
        "musiclab-be/utils/helper"
        "time"

        "github.com/go-playground/validator/v10"
        "golang.org/x/oauth2"
)

type authUseCase struct {
        qry         auth.AuthData
        qryTrans    transactions.TransactionData
        qryClass    classes.ClassData
        qryStudent  students.StudentData
        qrySchedule schedules.ScheduleData
        qryMentor   mentors.MentorData
        validate    *validator.Validate
        googleApi   helper.GoogleAPI
}

// LoginOauth implements auth.AuthService
func (auc *authUseCase) LoginOauth(input auth.Core) (string, auth.Core, error) <span class="cov8" title="1">{
        // validation
        if input.TokenOauth == "" </span><span class="cov8" title="1">{
                return "", auth.Core{}, errors.New("token oauth cannot empty")
        }</span>

        // get user info with token
        <span class="cov8" title="1">tokenOauth := &amp;oauth2.Token{
                AccessToken: input.TokenOauth,
        }

        coreGoogle, errUserInfo := auc.googleApi.GetUserInfo(tokenOauth)
        if errUserInfo != nil </span><span class="cov8" title="1">{
                return "", auth.Core{}, errUserInfo
        }</span>

        // find data by email
        <span class="cov8" title="1">res, errFindUser := auc.qry.FindAccount(coreGoogle.Email)
        if errFindUser != nil </span><span class="cov8" title="1">{
                return "", auth.Core{}, errFindUser
        }</span>

        // insert token oauth to data mentor or student
        <span class="cov8" title="1">if res.Role == "Mentor" </span><span class="cov8" title="1">{
                inputMentor := mentors.Core{}
                inputMentor.TokenOauth = input.TokenOauth

                errUpdateMentor := auc.qryMentor.UpdateData(res.ID, inputMentor)
                if errUpdateMentor != nil </span><span class="cov8" title="1">{
                        return "", auth.Core{}, errUpdateMentor
                }</span>
        } else<span class="cov8" title="1"> if res.Role == "Student" </span><span class="cov8" title="1">{
                inputStudent := students.Core{}
                inputStudent.TokenOauth = input.TokenOauth

                errUpdateStudent := auc.qryStudent.UpdateData(res.ID, inputStudent)
                if errUpdateStudent != nil </span><span class="cov8" title="1">{
                        return "", auth.Core{}, errUpdateStudent
                }</span>
        }

        // generate token jwt
        <span class="cov8" title="1">tokenJWT, errTokenJWT := helper.CreateToken(res.ID, res.Role)
        if errTokenJWT != nil </span><span class="cov0" title="0">{
                return "", auth.Core{}, errors.New(consts.AUTH_ErrorCreateToken)
        }</span>

        <span class="cov8" title="1">return tokenJWT, res, nil</span>
}

// RedirectGoogleCallback implements auth.AuthService
func (auc *authUseCase) RedirectGoogleCallback(code string) error <span class="cov8" title="1">{
        // get token oauth2
        token, errToken := auc.googleApi.GetToken(code)
        if errToken != nil </span><span class="cov0" title="0">{
                return errors.New("failed to get google oauth2 token")
        }</span>

        // get user info with token
        <span class="cov8" title="1">coreGoogle, errUserInfo := auc.googleApi.GetUserInfo(token)
        if errUserInfo != nil </span><span class="cov8" title="1">{
                return errUserInfo
        }</span>

        <span class="cov8" title="1">res, errFindUser := auc.qry.FindAccount(coreGoogle.Email)
        if errFindUser != nil </span><span class="cov8" title="1">{
                return errFindUser
        }</span>

        // insert token oauth to data mentor or student
        <span class="cov8" title="1">if res.Role == "Mentor" </span><span class="cov8" title="1">{
                inputMentor := mentors.Core{}
                inputMentor.TokenOauth = token.AccessToken

                errUpdateMentor := auc.qryMentor.UpdateData(res.ID, inputMentor)
                if errUpdateMentor != nil </span><span class="cov8" title="1">{
                        return errUpdateMentor
                }</span>
        } else<span class="cov8" title="1"> if res.Role == "Student" </span><span class="cov8" title="1">{
                inputStudent := students.Core{}
                inputStudent.TokenOauth = token.AccessToken

                errUpdateStudent := auc.qryStudent.UpdateData(res.ID, inputStudent)
                if errUpdateStudent != nil </span><span class="cov8" title="1">{
                        return errUpdateStudent
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// CreateEvent implements auth.AuthService
func (auc *authUseCase) CreateEvent(input auth.Core) error <span class="cov8" title="1">{
        // validation
        errValidate := auc.validate.StructExcept(input, "Name", "Email", "Password", "Role")
        if errValidate != nil </span><span class="cov8" title="1">{
                return errors.New("validate: " + errValidate.Error())
        }</span>

        // get token oauth2 from mentor data
        <span class="cov8" title="1">coreMentor, errMentor := auc.qryMentor.SelectProfile(input.ID)
        if errMentor != nil </span><span class="cov8" title="1">{
                return errMentor
        }</span>

        // token oauth2 validation
        <span class="cov8" title="1">if coreMentor.TokenOauth == "" </span><span class="cov0" title="0">{
                return errors.New("token oauth not generated yet, please login with google account first")
        }</span>

        // transaction detail
        <span class="cov8" title="1">coreTrans, errTrans := auc.qryTrans.SelectOne(input.TransactionID)
        if errTrans != nil </span><span class="cov8" title="1">{
                return errTrans
        }</span>

        // class detail
        <span class="cov8" title="1">coreClass, errClass := auc.qryClass.GetMentorClassDetail(coreTrans.ClassID)
        if errClass != nil </span><span class="cov8" title="1">{
                return errClass
        }</span>

        // student detail
        <span class="cov8" title="1">coreStudent, errStudent := auc.qryStudent.SelectProfile(coreTrans.StudentID)
        if errStudent != nil </span><span class="cov8" title="1">{
                return errStudent
        }</span>

        // schedule detail
        <span class="cov8" title="1">coreSchedule, errSchedule := auc.qrySchedule.DetailSchedule(coreTrans.ScheduleID)
        if errSchedule != nil </span><span class="cov8" title="1">{
                return errSchedule
        }</span>

        <span class="cov8" title="1">mapDay := map[time.Time]string{}

        start := coreTrans.StartDate
        end := coreTrans.EndDate
        for d := start; !d.After(end); d = d.AddDate(0, 0, 1) </span><span class="cov8" title="1">{
                dayString := d.Format("Monday")
                if dayString == coreSchedule.Day </span><span class="cov8" title="1">{
                        mapDay[d] = dayString
                        break</span>
                }
        }

        <span class="cov8" title="1">var firstDay time.Time
        for k := range mapDay </span><span class="cov8" title="1">{
                firstDay = k
        }</span>

        <span class="cov8" title="1">firstDayStr := firstDay.Format("2006-01-02 ") + coreSchedule.StartTime
        startTime, err := time.Parse("2006-01-02 15:04", firstDayStr)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("invalid start date format must YYYY-MM-DD")
        }</span>

        <span class="cov8" title="1">endDayStr := firstDay.Format("2006-01-02 ") + coreSchedule.EndTime
        endTime, err := time.Parse("2006-01-02 15:04", endDayStr)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("invalid start date format must YYYY-MM-DD")
        }</span>

        <span class="cov8" title="1">endDate := coreTrans.EndDate

        startRFC := startTime.Format(time.RFC3339)
        endRFC := endTime.Format(time.RFC3339)
        endDateRFC := endDate.Format(time.RFC3339)

        detailCal := helper.CalendarDetail{
                Summary:             coreClass.Name,
                Location:            coreStudent.Address,
                StartTime:           startRFC,
                EndTime:             endRFC,
                EndDate:             endDateRFC,
                CreatorDisplayName:  coreMentor.Name,
                CreatorEmail:        coreMentor.Email,
                AttendeeDisplayName: coreStudent.Name,
                AttendeeEmail:       coreStudent.Email,
        }

        token := &amp;oauth2.Token{
                AccessToken: coreMentor.TokenOauth,
        }

        errCreateEvent := auc.googleApi.CreateCalendar(token, detailCal)
        if errCreateEvent != nil </span><span class="cov0" title="0">{
                return errCreateEvent
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Register implements auth.AuthService
func (auc *authUseCase) Register(newUser auth.Core) error <span class="cov8" title="1">{
        errValidate := auc.validate.StructExcept(newUser, "TransactionID")
        if errValidate != nil </span><span class="cov8" title="1">{
                return errors.New("validate: " + errValidate.Error())
        }</span>

        <span class="cov8" title="1">errName := helper.OnlyLettersValidation(newUser.Name)
        if errName != nil </span><span class="cov8" title="1">{
                return errors.New(consts.MENTOR_NameOnlyLetters)
        }</span>

        // check duplicate email
        <span class="cov8" title="1">_, errFindUser := auc.qry.FindAccount(newUser.Email)
        if errFindUser == nil </span><span class="cov8" title="1">{
                return errors.New(consts.AUTH_DuplicateEmail)
        }</span>

        // default avatar
        <span class="cov8" title="1">newUser.Avatar = "https://cdn.pixabay.com/photo/2015/10/05/22/37/blank-profile-picture-973460_1280.png"

        hashed, errHash := helper.HashPassword(newUser.Password)
        if errHash != nil </span><span class="cov0" title="0">{
                return errors.New(consts.AUTH_ErrorHash)
        }</span>
        <span class="cov8" title="1">newUser.Password = string(hashed)

        if newUser.Role == "Mentor" </span><span class="cov8" title="1">{
                errMentor := auc.qry.RegisterMentor(newUser)
                if errMentor != nil </span><span class="cov8" title="1">{
                        return errMentor
                }</span>
        } else<span class="cov8" title="1"> if newUser.Role == "Student" </span><span class="cov8" title="1">{
                errStudent := auc.qry.RegisterStudent(newUser)
                if errStudent != nil </span><span class="cov8" title="1">{
                        return errStudent
                }</span>
        } else<span class="cov8" title="1"> {
                return errors.New(consts.AUTH_ErrorRole)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (auc *authUseCase) Login(user auth.Core) (string, auth.Core, error) <span class="cov8" title="1">{
        errValidate := auc.validate.StructExcept(user, "Name", "TransactionID")
        if errValidate != nil </span><span class="cov8" title="1">{
                return "", auth.Core{}, errors.New("validate: " + errValidate.Error())
        }</span>
        <span class="cov8" title="1">res := auth.Core{}
        if user.Role == "Mentor" </span><span class="cov8" title="1">{
                var err error
                res, err = auc.qry.LoginMentor(user.Email)
                if err != nil </span><span class="cov8" title="1">{
                        return "", auth.Core{}, err
                }</span>
        } else<span class="cov8" title="1"> if user.Role == "Student" </span><span class="cov8" title="1">{
                var err error
                res, err = auc.qry.LoginStudent(user.Email)
                if err != nil </span><span class="cov8" title="1">{
                        return "", auth.Core{}, err
                }</span>
        } else<span class="cov8" title="1"> {
                return "", auth.Core{}, errors.New(consts.AUTH_ErrorRole)
        }</span>

        <span class="cov8" title="1">if !helper.CompareHashPassword(user.Password, res.Password) </span><span class="cov8" title="1">{
                return "", auth.Core{}, errors.New(consts.AUTH_ErrorComparePassword)
        }</span>

        <span class="cov8" title="1">token, errToken := helper.CreateToken(res.ID, res.Role)
        if errToken != nil </span><span class="cov0" title="0">{
                return "", auth.Core{}, errors.New(consts.AUTH_ErrorCreateToken)
        }</span>

        <span class="cov8" title="1">return token, res, nil</span>
}

func New(ud auth.AuthData, ga helper.GoogleAPI, td transactions.TransactionData, cd classes.ClassData, sd students.StudentData, scd schedules.ScheduleData, md mentors.MentorData) auth.AuthService <span class="cov8" title="1">{
        return &amp;authUseCase{
                qry:         ud,
                qryTrans:    td,
                qryClass:    cd,
                qryStudent:  sd,
                qrySchedule: scd,
                qryMentor:   md,
                validate:    validator.New(),
                googleApi:   ga,
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package services

import (
        "errors"
        "musiclab-be/features/chats"
        "musiclab-be/features/mentors"
        "musiclab-be/features/students"
        "musiclab-be/utils/consts"

        "github.com/go-playground/validator/v10"
)

type chatUseCase struct {
        qry        chats.ChatData
        qrymentor  mentors.MentorData
        qrystudent students.StudentData
        validate   *validator.Validate
}

// GetAll implements chats.ChatService
func (cuc *chatUseCase) GetAll(mentorID uint, studentID uint) ([]chats.Core, error) <span class="cov8" title="1">{
        dataCore, err := cuc.qry.GetAll(mentorID, studentID)
        if err != nil </span><span class="cov8" title="1">{
                return []chats.Core{}, err
        }</span>
        <span class="cov8" title="1">return dataCore, nil</span>
}

// GetByStudent implements chats.ChatService
func (cuc *chatUseCase) GetByStudent(page, limit int, mentorID uint) ([]chats.Core, error) <span class="cov8" title="1">{
        offset := (page - 1) * limit
        dataCore, err := cuc.qry.GetByStudent(limit, offset, mentorID)
        if err != nil </span><span class="cov8" title="1">{
                return []chats.Core{}, err
        }</span>
        <span class="cov8" title="1">return dataCore, nil</span>
}

// InsertChat implements chats.ChatService
func (cuc *chatUseCase) InsertChat(input chats.Core) error <span class="cov8" title="1">{
        errValidate := cuc.validate.StructExcept(input, "Student")
        if errValidate != nil </span><span class="cov8" title="1">{
                return errors.New("validate: " + errValidate.Error())
        }</span>

        // mentor id validation
        <span class="cov8" title="1">_, errMentorID := cuc.qrymentor.SelectProfile(input.MentorID)
        if errMentorID != nil </span><span class="cov8" title="1">{
                return errors.New(consts.CHAT_ErrorMentorID)
        }</span>

        // student id validation
        <span class="cov8" title="1">_, errStudentID := cuc.qrystudent.SelectProfile(input.StudentID)
        if errStudentID != nil </span><span class="cov8" title="1">{
                return errors.New(consts.CHAT_ErrorStudentID)
        }</span>

        <span class="cov8" title="1">if input.Role == "Mentor" </span><span class="cov8" title="1">{
                mentorCore, errMentor := cuc.qrymentor.SelectProfile(input.MentorID)
                if errMentor != nil </span><span class="cov8" title="1">{
                        return errMentor
                }</span>
                <span class="cov8" title="1">input.SenderName = mentorCore.Name</span>
        } else<span class="cov8" title="1"> if input.Role == "Student" </span><span class="cov8" title="1">{
                studentCore, errStudent := cuc.qrystudent.SelectProfile(input.StudentID)
                if errStudent != nil </span><span class="cov8" title="1">{
                        return errStudent
                }</span>
                <span class="cov8" title="1">input.SenderName = studentCore.Name</span>
        }

        <span class="cov8" title="1">errInsert := cuc.qry.InsertChat(input)
        if errInsert != nil </span><span class="cov8" title="1">{
                return errInsert
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func New(cd chats.ChatData, md mentors.MentorData, sd students.StudentData) chats.ChatService <span class="cov8" title="1">{
        return &amp;chatUseCase{
                qry:        cd,
                qrymentor:  md,
                qrystudent: sd,
                validate:   validator.New(),
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package services

import (
        "errors"
        "log"
        "mime/multipart"
        "musiclab-be/features/classes"
        "musiclab-be/utils/helper"
        "strings"
)

type classUseCase struct {
        qry classes.ClassData
}

func New(cd classes.ClassData) classes.ClassService <span class="cov8" title="1">{
        return &amp;classUseCase{
                qry: cd,
        }
}</span>

func (cuc *classUseCase) PostClass(fileData multipart.FileHeader, newClass classes.Core) error <span class="cov8" title="1">{
        url, err := helper.GetUrlImagesFromAWS(fileData)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("validate: " + err.Error())
        }</span>
        <span class="cov8" title="1">newClass.Image = url
        err = cuc.qry.PostClass(newClass)
        if err != nil </span><span class="cov8" title="1">{
                msg := ""
                if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        msg = "data not found"
                }</span> else<span class="cov8" title="1"> {
                        msg = "server problem"
                }</span>
                <span class="cov8" title="1">log.Println("error add query in service: ", err.Error())
                return errors.New(msg)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (cuc *classUseCase) GetMentorClass(mentorID uint, page, limit int) ([]classes.Core, error) <span class="cov8" title="1">{
        offset := (page - 1) * limit
        res, err := cuc.qry.GetMentorClass(mentorID, limit, offset)

        if err != nil </span><span class="cov8" title="1">{
                msg := ""
                if strings.Contains(err.Error(), "not found") </span><span class="cov8" title="1">{
                        msg = "class not found"
                }</span> else<span class="cov8" title="1"> {
                        msg = "there is a problem with the server"
                }</span>
                <span class="cov8" title="1">return []classes.Core{}, errors.New(msg)</span>
        }

        <span class="cov8" title="1">return res, nil</span>
}

func (cuc *classUseCase) GetMentorClassDetail(classID uint) (classes.Core, error) <span class="cov8" title="1">{
        res, err := cuc.qry.GetMentorClassDetail(classID)

        if err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), "not found") </span><span class="cov8" title="1">{
                        return classes.Core{}, errors.New("data not found")
                }</span> else<span class="cov8" title="1"> {
                        return classes.Core{}, errors.New("internal server error")
                }</span>
        }

        <span class="cov8" title="1">return res, nil</span>
}

func (cuc *classUseCase) Update(mentorID uint, classID uint, fileData multipart.FileHeader, updatedClass classes.Core) error <span class="cov8" title="1">{
        url, err := helper.GetUrlImagesFromAWS(fileData)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("validate: " + err.Error())
        }</span>
        <span class="cov8" title="1">updatedClass.Image = url
        err = cuc.qry.Update(uint(mentorID), classID, updatedClass)

        if err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), "not found") </span><span class="cov8" title="1">{
                        return errors.New("data not found")
                }</span> else<span class="cov8" title="1"> {
                        return errors.New("internal server error")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (cuc *classUseCase) Delete(mentorID uint, classID uint) error <span class="cov8" title="1">{
        err := cuc.qry.Delete(mentorID, classID)

        if err != nil </span><span class="cov8" title="1">{
                log.Println("delete query error", err.Error())
                return errors.New("data not found")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package services

import (
        "errors"
        "log"
        "musiclab-be/features/genres"
        "strings"
)

type genreUseCase struct {
        qry genres.GenreData
}

func New(gd genres.GenreData) genres.GenreService <span class="cov8" title="1">{
        return &amp;genreUseCase{
                qry: gd,
        }
}</span>

func (guu *genreUseCase) AddMentorGenre(newGenre genres.Core) error <span class="cov8" title="1">{
        err := guu.qry.AddMentorGenre(newGenre)
        if err != nil </span><span class="cov8" title="1">{
                msg := ""
                if strings.Contains(err.Error(), "not found") </span><span class="cov8" title="1">{
                        msg = "data not found"
                }</span> else<span class="cov0" title="0"> {
                        msg = "server problem"
                }</span>
                <span class="cov8" title="1">log.Println("error add query in service: ", err.Error())
                return errors.New(msg)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetGenre implements genres.GenreService
func (guc *genreUseCase) GetGenre() ([]genres.Core, error) <span class="cov8" title="1">{
        res, err := guc.qry.GetGenre()
        if err != nil </span><span class="cov8" title="1">{
                msg := ""
                if strings.Contains(err.Error(), "not found") </span><span class="cov8" title="1">{
                        msg = "genre not found"
                }</span> else<span class="cov8" title="1"> {
                        msg = "there is a problem with the server"
                }</span>
                <span class="cov8" title="1">return []genres.Core{}, errors.New(msg)</span>
        }
        <span class="cov8" title="1">return res, nil</span>
}

func (guc *genreUseCase) GetMentorGenre(mentorID uint) ([]genres.MentorGenreCore, error) <span class="cov8" title="1">{
        res, err := guc.qry.GetMentorGenre(mentorID)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("query error", err.Error())
                return []genres.MentorGenreCore{}, errors.New("query error, problem with server")
        }</span>
        <span class="cov8" title="1">return res, nil</span>
}

func (guc *genreUseCase) Delete(mentorID, genreID uint) error <span class="cov8" title="1">{
        err := guc.qry.Delete(mentorID, genreID)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("query error", err.Error())
                return errors.New("query error, problem with server")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package services

import (
        "errors"
        "musiclab-be/features/instruments"

        "github.com/go-playground/validator/v10"
)

type instrumentUseCase struct {
        qry      instruments.InstrumentData
        validate *validator.Validate
}

// Delete implements instruments.InstrumentService
func (iuc *instrumentUseCase) Delete(mentorID uint, instrumentID uint) error <span class="cov8" title="1">{
        err := iuc.qry.Delete(mentorID, instrumentID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Insert implements instruments.InstrumentService
func (iuc *instrumentUseCase) Insert(input instruments.MentorInstrumentCore) error <span class="cov8" title="1">{
        errValidate := iuc.validate.Struct(input)
        if errValidate != nil </span><span class="cov8" title="1">{
                return errors.New("validate: " + errValidate.Error())
        }</span>

        <span class="cov8" title="1">errInsert := iuc.qry.Insert(input)
        if errInsert != nil </span><span class="cov8" title="1">{
                return errInsert
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SelectAll implements instruments.InstrumentService
func (iuc *instrumentUseCase) SelectAll() ([]instruments.Core, error) <span class="cov8" title="1">{
        data, err := iuc.qry.SelectAll()
        return data, err
}</span>

// SelectAllByMentorID implements instruments.InstrumentService
func (iuc *instrumentUseCase) SelectAllByMentorID(mentorID uint) ([]instruments.MentorInstrumentCore, error) <span class="cov8" title="1">{
        data, err := iuc.qry.SelectAllByMentorID(mentorID)
        return data, err
}</span>

func New(id instruments.InstrumentData) instruments.InstrumentService <span class="cov8" title="1">{
        return &amp;instrumentUseCase{
                qry:      id,
                validate: validator.New(),
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package services

import (
        "errors"
        "musiclab-be/features/mentors"
        "musiclab-be/utils/consts"
        "musiclab-be/utils/helper"

        "github.com/go-playground/validator/v10"
)

type mentorUseCase struct {
        qry      mentors.MentorData
        validate *validator.Validate
}

// SelectAllByRating implements mentors.MentorService
func (muc *mentorUseCase) SelectAllByRating() ([]mentors.Core, error) <span class="cov8" title="1">{
        dataCore, err := muc.qry.SelectAllByRating()
        if err != nil </span><span class="cov8" title="1">{
                return []mentors.Core{}, err
        }</span>
        <span class="cov8" title="1">return dataCore, nil</span>
}

// SelectAll implements mentors.MentorService
func (muc *mentorUseCase) SelectAll(page int, limit int, filter mentors.MentorFilter) ([]mentors.Core, error) <span class="cov8" title="1">{
        errName := helper.OnlyLettersValidation(filter.Name)
        if errName != nil </span><span class="cov0" title="0">{
                return []mentors.Core{}, errors.New(consts.MENTOR_NameOnlyLetters)
        }</span>

        <span class="cov8" title="1">offset := (page - 1) * limit
        dataCore, err := muc.qry.SelectAll(limit, offset, filter)
        if err != nil </span><span class="cov8" title="1">{
                return []mentors.Core{}, err
        }</span>
        <span class="cov8" title="1">return dataCore, nil</span>
}

// Delete implements mentors.MentorService
func (muc *mentorUseCase) Delete(mentorID uint) error <span class="cov8" title="1">{
        err := muc.qry.Delete(mentorID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// InsertCredential implements mentors.MentorService
func (muc *mentorUseCase) InsertCredential(input mentors.CredentialCore) error <span class="cov8" title="1">{
        errValidate := muc.validate.Struct(input)
        if errValidate != nil </span><span class="cov0" title="0">{
                return errors.New("validate: " + errValidate.Error())
        }</span>

        <span class="cov8" title="1">url, errUpload := helper.GetUrlImagesFromAWS(input.CertificateFile)
        if errUpload != nil </span><span class="cov0" title="0">{
                return errors.New(consts.AWS_ErrorUpload)
        }</span>

        <span class="cov8" title="1">input.Certificate = url

        errInsert := muc.qry.InsertCredential(input)
        if errInsert != nil </span><span class="cov8" title="1">{
                return errInsert
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UpdatePassword implements mentors.MentorService
func (muc *mentorUseCase) UpdatePassword(mentorID uint, input mentors.Core) error <span class="cov8" title="1">{
        if input.Password == "" || input.NewPassword == "" || input.ConfirmationPassword == "" </span><span class="cov8" title="1">{
                return errors.New(consts.AUTH_ErrorEmptyPassword)
        }</span>

        <span class="cov8" title="1">dataCore, errSelect := muc.qry.SelectProfile(mentorID)
        if errSelect != nil </span><span class="cov8" title="1">{
                return errSelect
        }</span>

        <span class="cov8" title="1">if !helper.CompareHashPassword(input.Password, dataCore.Password) </span><span class="cov8" title="1">{
                return errors.New(consts.AUTH_ErrorComparePassword)
        }</span>

        <span class="cov8" title="1">if input.NewPassword != input.ConfirmationPassword </span><span class="cov0" title="0">{
                return errors.New(consts.AUTH_ErrorNewPassword)
        }</span>

        <span class="cov8" title="1">hash, errHash := helper.HashPassword(input.NewPassword)
        if errHash != nil </span><span class="cov0" title="0">{
                return errors.New(consts.AUTH_ErrorHash)
        }</span>

        <span class="cov8" title="1">input.Password = hash

        errUpdate := muc.qry.UpdateData(mentorID, input)
        if errUpdate != nil </span><span class="cov8" title="1">{
                return errUpdate
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UpdateData implements mentors.MentorService
func (muc *mentorUseCase) UpdateData(mentorID uint, input mentors.Core) error <span class="cov8" title="1">{
        errValidate := muc.validate.StructExcept(input, "Password", "MentorInstrument")
        if errValidate != nil </span><span class="cov0" title="0">{
                return errors.New("validate: " + errValidate.Error())
        }</span>

        <span class="cov8" title="1">errName := helper.OnlyLettersValidation(input.Name)
        if errName != nil </span><span class="cov0" title="0">{
                return errors.New(consts.MENTOR_NameOnlyLetters)
        }</span>

        <span class="cov8" title="1">url, errUpload := helper.GetUrlImagesFromAWS(input.AvatarFile)
        if errUpload != nil </span><span class="cov0" title="0">{
                return errors.New(consts.AWS_ErrorUpload)
        }</span>

        <span class="cov8" title="1">input.Avatar = url

        errUpdate := muc.qry.UpdateData(mentorID, input)
        if errUpdate != nil </span><span class="cov8" title="1">{
                return errUpdate
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SelectProfile implements mentors.MentorService
func (muc *mentorUseCase) SelectProfile(mentorID uint) (mentors.Core, error) <span class="cov8" title="1">{
        dataCore, err := muc.qry.SelectProfile(mentorID)
        if err != nil </span><span class="cov8" title="1">{
                return mentors.Core{}, err
        }</span>
        <span class="cov8" title="1">return dataCore, nil</span>
}

func New(md mentors.MentorData) mentors.MentorService <span class="cov8" title="1">{
        return &amp;mentorUseCase{
                qry:      md,
                validate: validator.New(),
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package services

import (
        "errors"
        "log"
        "musiclab-be/features/reviews"
        "strings"
)

type reviewUseCase struct {
        qry reviews.ReviewData
}

func New(rd reviews.ReviewData) reviews.ReviewService <span class="cov8" title="1">{
        return &amp;reviewUseCase{
                qry: rd,
        }
}</span>

func (ruc *reviewUseCase) PostMentorReview(mentorID uint, newReview reviews.Core) error <span class="cov8" title="1">{
        err := ruc.qry.PostMentorReview(mentorID, newReview)
        if err != nil </span><span class="cov8" title="1">{
                msg := ""
                if strings.Contains(err.Error(), "not found") </span><span class="cov8" title="1">{
                        msg = "data not found"
                }</span> else<span class="cov8" title="1"> {
                        msg = "server problem"
                }</span>
                <span class="cov8" title="1">log.Println("error add query in service: ", err.Error())
                return errors.New(msg)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (ruc *reviewUseCase) GetMentorReview(page, limit int, mentorID uint) ([]reviews.Core, error) <span class="cov8" title="1">{
        offset := (page - 1) * limit

        res, err := ruc.qry.GetMentorReview(limit, offset, mentorID)

        if err != nil </span><span class="cov8" title="1">{
                msg := ""
                if strings.Contains(err.Error(), "not found") </span><span class="cov8" title="1">{
                        msg = "review not found"
                }</span> else<span class="cov8" title="1"> {
                        msg = "there is a problem with the server"
                }</span>
                <span class="cov8" title="1">return []reviews.Core{}, errors.New(msg)</span>
        }

        <span class="cov8" title="1">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package services

import (
        "errors"
        "log"
        "musiclab-be/features/classes"
        "musiclab-be/features/schedules"
        "strings"
        "time"

        "github.com/go-playground/validator/v10"
)

type scheduleUseCase struct {
        qry      schedules.ScheduleData
        qryClass classes.ClassData
        validate *validator.Validate
}

func New(sd schedules.ScheduleData, cd classes.ClassData) schedules.ScheduleService <span class="cov8" title="1">{
        return &amp;scheduleUseCase{
                qry:      sd,
                qryClass: cd,
                validate: validator.New(),
        }
}</span>

// CheckSchedule implements schedules.ScheduleService
func (suc *scheduleUseCase) CheckSchedule(input schedules.Core) error <span class="cov8" title="1">{
        errValidate := suc.validate.Struct(input)
        if errValidate != nil </span><span class="cov8" title="1">{
                return errors.New("validate: " + errValidate.Error())
        }</span>

        // start date validation
        <span class="cov8" title="1">year := time.Now().Year()
        month := time.Now().Month()
        date := time.Now().Day()
        today := time.Date(year, month, date, 0, 0, 0, 0, time.UTC)

        dateValidation := input.Transaction.StartDate.Before(today)
        if dateValidation </span><span class="cov8" title="1">{
                return errors.New("minimum start date input is today")
        }</span>

        // get mentor id by class id
        <span class="cov8" title="1">coreClass, errGetClass := suc.qryClass.GetMentorClassDetail(input.ClassID)
        if errGetClass != nil </span><span class="cov8" title="1">{
                return errGetClass
        }</span>

        <span class="cov8" title="1">input.MentorID = coreClass.MentorID

        // calculate end date
        countDay := int(coreClass.Duration * 30)

        endDate := input.Transaction.StartDate.AddDate(0, 0, countDay)
        input.Transaction.EndDate = endDate

        // check availability
        rows, errCheck := suc.qry.CheckSchedule(input)
        if errCheck != nil </span><span class="cov8" title="1">{
                return errCheck
        }</span>

        <span class="cov8" title="1">if rows != 0 </span><span class="cov8" title="1">{
                return errors.New("schedule not available")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (suc *scheduleUseCase) PostSchedule(newSchedule schedules.Core) error <span class="cov8" title="1">{
        err := suc.qry.PostSchedule(newSchedule)
        if err != nil </span><span class="cov8" title="1">{
                msg := ""
                if strings.Contains(err.Error(), "not found") </span><span class="cov8" title="1">{
                        msg = "data not found"
                }</span> else<span class="cov8" title="1"> {
                        msg = "server problem"
                }</span>
                <span class="cov8" title="1">log.Println("error add query in service: ", err.Error())
                return errors.New(msg)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (suc *scheduleUseCase) GetMentorSchedule(mentorID uint) ([]schedules.Core, error) <span class="cov8" title="1">{
        res, err := suc.qry.GetMentorSchedule(mentorID)

        if err != nil </span><span class="cov8" title="1">{
                msg := ""
                if strings.Contains(err.Error(), "not found") </span><span class="cov8" title="1">{
                        msg = "schedule not found"
                }</span> else<span class="cov8" title="1"> {
                        msg = "there is a problem with the server"
                }</span>
                <span class="cov8" title="1">return []schedules.Core{}, errors.New(msg)</span>
        }

        <span class="cov8" title="1">return res, nil</span>
}

func (suc *scheduleUseCase) Delete(mentorID uint, scheduleID uint) error <span class="cov8" title="1">{
        err := suc.qry.Delete(mentorID, scheduleID)

        if err != nil </span><span class="cov8" title="1">{
                log.Println("delete query error", err.Error())
                return errors.New("data not found")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package services

import (
        "errors"
        "musiclab-be/features/students"
        "musiclab-be/utils/consts"
        "musiclab-be/utils/helper"

        "github.com/go-playground/validator/v10"
)

type studentUseCase struct {
        qry      students.StudentData
        validate *validator.Validate
}

// Delete implements students.StudentService
func (suc *studentUseCase) Delete(studentID uint) error <span class="cov8" title="1">{
        err := suc.qry.Delete(studentID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SelectProfile implements students.StudentService
func (suc *studentUseCase) SelectProfile(studentID uint) (students.Core, error) <span class="cov8" title="1">{
        dataCore, err := suc.qry.SelectProfile(studentID)
        if err != nil </span><span class="cov8" title="1">{
                return students.Core{}, err
        }</span>
        <span class="cov8" title="1">return dataCore, nil</span>
}

// UpdateData implements students.StudentService
func (suc *studentUseCase) UpdateData(studentID uint, input students.Core) error <span class="cov8" title="1">{
        errValidate := suc.validate.StructExcept(input, "Password")
        if errValidate != nil </span><span class="cov0" title="0">{
                return errors.New("validate: " + errValidate.Error())
        }</span>

        <span class="cov8" title="1">errName := helper.OnlyLettersValidation(input.Name)
        if errName != nil </span><span class="cov0" title="0">{
                return errors.New(consts.MENTOR_NameOnlyLetters)
        }</span>

        <span class="cov8" title="1">url, errUpload := helper.GetUrlImagesFromAWS(input.AvatarFile)
        if errUpload != nil </span><span class="cov0" title="0">{
                return errors.New(consts.AWS_ErrorUpload)
        }</span>

        <span class="cov8" title="1">input.Avatar = url

        errUpdate := suc.qry.UpdateData(studentID, input)
        if errUpdate != nil </span><span class="cov8" title="1">{
                return errUpdate
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// UpdatePassword implements students.StudentService
func (suc *studentUseCase) UpdatePassword(studentID uint, input students.Core) error <span class="cov8" title="1">{
        if input.Password == "" || input.NewPassword == "" || input.ConfirmationPassword == "" </span><span class="cov8" title="1">{
                return errors.New(consts.AUTH_ErrorEmptyPassword)
        }</span>

        <span class="cov8" title="1">dataCore, errSelect := suc.qry.SelectProfile(studentID)
        if errSelect != nil </span><span class="cov8" title="1">{
                return errSelect
        }</span>

        <span class="cov8" title="1">if !helper.CompareHashPassword(input.Password, dataCore.Password) </span><span class="cov8" title="1">{
                return errors.New(consts.AUTH_ErrorComparePassword)
        }</span>

        <span class="cov8" title="1">if input.NewPassword != input.ConfirmationPassword </span><span class="cov0" title="0">{
                return errors.New(consts.AUTH_ErrorNewPassword)
        }</span>

        <span class="cov8" title="1">hash, errHash := helper.HashPassword(input.NewPassword)
        if errHash != nil </span><span class="cov0" title="0">{
                return errors.New(consts.AUTH_ErrorHash)
        }</span>

        <span class="cov8" title="1">input.Password = hash

        errUpdate := suc.qry.UpdateData(studentID, input)
        if errUpdate != nil </span><span class="cov8" title="1">{
                return errUpdate
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func New(sd students.StudentData) students.StudentService <span class="cov8" title="1">{
        return &amp;studentUseCase{
                qry:      sd,
                validate: validator.New(),
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package services

import (
        "errors"
        "musiclab-be/features/classes"
        "musiclab-be/features/students"
        "musiclab-be/features/transactions"
        "musiclab-be/utils/helper"
        "strings"
        "time"
)

type transactionUseCase struct {
        qry        transactions.TransactionData
        qryClass   classes.ClassData
        qryStudent students.StudentData
}

func New(td transactions.TransactionData, sd students.StudentData, cd classes.ClassData) transactions.TransactionService <span class="cov8" title="1">{
        return &amp;transactionUseCase{
                qry:        td,
                qryClass:   cd,
                qryStudent: sd,
        }
}</span>

// UpdateTransaction implements transactions.TransactionService
func (tuc *transactionUseCase) UpdateTransaction(input transactions.Core) error <span class="cov8" title="1">{
        err := tuc.qry.UpdateTransaction(input)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (tuc *transactionUseCase) MakeTransaction(newTransaction transactions.Core) (transactions.Core, error) <span class="cov8" title="1">{
        // start date validation
        year := time.Now().Year()
        month := time.Now().Month()
        date := time.Now().Day()
        today := time.Date(year, month, date, 0, 0, 0, 0, time.UTC)

        dateValidation := newTransaction.StartDate.Before(today)
        if dateValidation </span><span class="cov8" title="1">{
                return transactions.Core{}, errors.New("minimum start date input is today")
        }</span>

        <span class="cov8" title="1">selectClass, errSelectClass := tuc.qryClass.GetMentorClassDetail(newTransaction.ClassID)
        if errSelectClass != nil </span><span class="cov8" title="1">{
                return transactions.Core{}, errSelectClass
        }</span>

        <span class="cov8" title="1">selectStudent, errSelectStudent := tuc.qryStudent.SelectProfile(newTransaction.StudentID)
        if errSelectStudent != nil </span><span class="cov8" title="1">{
                return transactions.Core{}, errSelectStudent
        }</span>

        <span class="cov8" title="1">countDay := int(selectClass.Duration * 30)

        endDate := newTransaction.StartDate.AddDate(0, 0, countDay)
        newTransaction.EndDate = endDate
        newTransaction.MentorID = selectClass.MentorID
        newTransaction.Price = selectClass.Price
        newTransaction.Status = "Pending"

        midtransResponse, errSnap := helper.RequestSnapMidtrans(selectStudent, selectClass, newTransaction)
        if errSnap != nil </span><span class="cov8" title="1">{
                return transactions.Core{}, errSnap
        }</span>

        <span class="cov0" title="0">newTransaction.OrderID = midtransResponse.OrderID
        newTransaction.PaymentUrl = midtransResponse.PaymentUrl

        err := tuc.qry.MakeTransaction(newTransaction)
        if err != nil </span><span class="cov0" title="0">{
                return transactions.Core{}, err
        }</span>

        <span class="cov0" title="0">return midtransResponse, nil</span>
}

func (tuc *transactionUseCase) GetMentorTransaction(mentorID uint, page, limit int) ([]transactions.Core, error) <span class="cov8" title="1">{
        offset := (page - 1) * limit
        res, err := tuc.qry.GetMentorTransaction(mentorID, limit, offset)

        if err != nil </span><span class="cov8" title="1">{
                msg := ""
                if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        msg = "review not found"
                }</span> else<span class="cov8" title="1"> {
                        msg = "there is a problem with the server"
                }</span>
                <span class="cov8" title="1">return []transactions.Core{}, errors.New(msg)</span>
        }

        <span class="cov8" title="1">return res, nil</span>
}

// GetStudentTransaction implements transactions.TransactionService
func (tuc *transactionUseCase) GetStudentTransaction(studentID uint, page, limit int) ([]transactions.Core, error) <span class="cov8" title="1">{
        offset := (page - 1) * limit
        res, err := tuc.qry.GetStudentTransaction(studentID, limit, offset)

        if err != nil </span><span class="cov8" title="1">{
                msg := ""
                if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        msg = "review not found"
                }</span> else<span class="cov8" title="1"> {
                        msg = "there is a problem with the server"
                }</span>
                <span class="cov8" title="1">return []transactions.Core{}, errors.New(msg)</span>
        }

        <span class="cov8" title="1">return res, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
